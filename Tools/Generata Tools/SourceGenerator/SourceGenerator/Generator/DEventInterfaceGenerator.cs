using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator.Generator;

[Generator]
public class DEventInterfaceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // 初始化
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // 获取当前语法树
        var syntaxTrees = context.Compilation.SyntaxTrees;
        GenerateGameEventExecute(context, syntaxTrees);
        //GenerateRuntimeInitializeOnLoadMethodExecute(context, syntaxTrees);
        //GenerateRequireComponentExecute(context, syntaxTrees);
        //GenerateTextDefineEnumExecute(context, syntaxTrees);
    }

    #region GenerateGameEvent

    private void GenerateGameEventExecute(GeneratorExecutionContext context, IEnumerable<SyntaxTree> syntaxTrees)
    {
        List<string> classNameList = new List<string>();

        foreach (var tree in syntaxTrees)
        {
            // 获取语法树的根节点
            var root = tree.GetRoot();

            // 获取当前语法树中的所有命名空间节点
            var namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();

            // 判断语法树是否在指定检测的命名空间下
            if (namespaces.All(ns => !Definition.TargetNameSpaces.Contains(ns.Name.ToString())))
            {
                continue;
            }

            var interfaces = GetMatchInterfaces(root);

            foreach (var interfaceNode in interfaces)
            {
                var interfaceName = interfaceNode.Identifier.ToString();
                var fullName = GetInterfaceFullName(interfaceNode, interfaceName);
                var eventClassName = $"{interfaceName}_Event";
                var eventClassCode = GenerateEventClass(interfaceName, eventClassName, interfaceNode);
                context.AddSource($"{eventClassName}.g.cs", eventClassCode);

                // 生成实现类
                var implementationClassCode =
                    GenerateImplementationClass(fullName, interfaceName, interfaceNode, context);
                context.AddSource($"{interfaceName}_Gen.g.cs", implementationClassCode);
                classNameList.Add($"{interfaceName}_Gen");
            }
        }

        if (classNameList.Count > 0)
        {
            string uniqueFileName = $"GameEventLauncher.g.cs";
            context.AddSource(uniqueFileName, GenerateGameEventHelper(classNameList));
        }
    }

    /// <summary>
    /// 生成事件中心启动器脚本
    /// </summary>
    /// <param name="classNameList"></param>
    /// <returns></returns>
    private string GenerateGameEventHelper(List<string> classNameList)
    {
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine();

        foreach (var usingNameSpace in Definition.UsingNameSpace)
        {
            sb.AppendLine($"using {usingNameSpace};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.NameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic static class GameEventLauncher");
            {
                sb.AppendLine("\t{");
                sb.AppendLine($"\t\tpublic static void Init()");
                {
                    sb.AppendLine("\t\t{");

                    foreach (var className in classNameList)
                    {
                        sb.AppendLine($"\t\t\tvar m_{className} = new {className}(GameEvent.EventMgr.Dispatcher);");
                    }

                    // sb.AppendLine($"\t\t\t{Definition.DefaultDebugName}.Info(\"事件中心初始化\");");
                    sb.AppendLine("\t\t}");
                }
                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// 生成接口实现类
    /// </summary>
    /// <param name="fullName"></param>
    /// <param name="interfaceName"></param>
    /// <param name="interfaceNode"></param>
    /// <param name="context"></param>
    /// <returns></returns>
    private string GenerateImplementationClass(string fullName, string interfaceName,
        InterfaceDeclarationSyntax interfaceNode, GeneratorExecutionContext context)
    {
        // 获取接口节点语法模型
        var semanticModel = context.Compilation.GetSemanticModel(interfaceNode.SyntaxTree);
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine();

        foreach (var usingNameSpace in Definition.UsingNameSpace)
        {
            sb.AppendLine($"using {usingNameSpace};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.NameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic partial class {interfaceName}_Gen : {interfaceName}");
            {
                sb.AppendLine("\t{");
                sb.AppendLine("\t\tprivate EventDispatcher m_dispatcher;");
                sb.AppendLine();
                sb.AppendLine($"\t\tpublic {interfaceName}_Gen(EventDispatcher dispatcher)");
                {
                    sb.AppendLine("\t\t{");
                    sb.AppendLine("\t\t\tm_dispatcher = dispatcher;");
                    // sb.AppendLine($"\t\t\tGameEvent.EventMgr.RegWrapInterface(\"{fullName}\", this);");
                    sb.AppendLine($"\t\t\tGameEvent.EventMgr.RegWrapInterface<{fullName}>(this);");
                    sb.AppendLine("\t\t}");
                }
                sb.AppendLine();
                var methods = interfaceNode.Members.OfType<MethodDeclarationSyntax>();

                for (int i = 0; i < methods.Count(); i++)
                {
                    var method = methods.ElementAt(i);
                    var methodName = method.Identifier.ToString();
                    var parameters = GenerateParameters(method, semanticModel);
                    sb.AppendLine($"\t\tpublic void {methodName}({parameters})");
                    {
                        sb.AppendLine("\t\t{");

                        if (method.ParameterList.Parameters.Count > 0)
                        {
                            var paramNames = string.Join(", ",
                                method.ParameterList.Parameters.Select(p => p.Identifier.ToString()));
                            sb.AppendLine(
                                $"\t\t\tm_dispatcher.Send({interfaceName}_Event.{methodName}, {paramNames});");
                        }
                        else
                        {
                            sb.AppendLine($"\t\t\tm_dispatcher.Send({interfaceName}_Event.{methodName});");
                        }

                        sb.AppendLine("\t\t}");
                    }

                    if (i < methods.Count() - 1)
                    {
                        sb.AppendLine();
                    }
                }

                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private string GenerateParameters(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        return string.Join(", ", method.ParameterList.Parameters.Select(p =>
        {
            var typeSymbol = semanticModel.GetTypeInfo(p.Type).Type;
            return typeSymbol != null
                ? $"{typeSymbol.ToDisplayString()} {p.Identifier}"
                : $"{p.Type} {p.Identifier}";
        }));
    }

    /// <summary>
    /// 生成接口字典key类
    /// </summary>
    /// <param name="interfaceName"></param>
    /// <param name="eventClassName"></param>
    /// <param name="interfaceNode"></param>
    /// <returns></returns>
    private string GenerateEventClass(string interfaceName, string eventClassName,
        InterfaceDeclarationSyntax interfaceNode)
    {
        // 获取接口在的所有方法
        var methods = interfaceNode.Members.OfType<MethodDeclarationSyntax>();
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");

        sb.AppendLine();

        foreach (var usingNameSpace in Definition.UsingNameSpace)
        {
            sb.AppendLine($"using {usingNameSpace};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.NameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic partial class {eventClassName}");
            {
                sb.AppendLine("\t{");

                foreach (var method in methods)
                {
                    var methodName = method.Identifier.ToString();
                    var parameters = string.Join(", ",
                        method.ParameterList.Parameters.Select(p => $"{p.Type} {p.Identifier}"));
                    sb.AppendLine(
                        $"\t\tpublic static readonly int {methodName} = {Definition.StringToHash}(\"{eventClassName}.{methodName}\");");
                }

                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }
        return sb.ToString();
    }

    /// <summary>
    /// 获取接口的FullName 带命名空间
    /// </summary>
    /// <param name="interfaceNode"></param>
    /// <param name="interfaceName"></param>
    /// <returns></returns>
    private string GetInterfaceFullName(InterfaceDeclarationSyntax interfaceNode, string interfaceName)
    {
        var fullName = interfaceNode.SyntaxTree.GetRoot()
            .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
            .Select(nameSpace => nameSpace.Name.ToString())
            .Concat([interfaceName])
            .Aggregate((a, b) => $"{a}.{b}");
        return fullName;
    }

    /// <summary>
    /// 获取匹配的接口声明语法
    /// </summary>
    /// <param name="root"></param>
    /// <returns></returns>
    private IEnumerable<InterfaceDeclarationSyntax> GetMatchInterfaces(SyntaxNode root)
    {
        return root.DescendantNodes().OfType<InterfaceDeclarationSyntax>()
            .Where(i => i.AttributeLists.Count > 0
                        && i.AttributeLists.Any(attrList => attrList.Attributes
                            .Any(attr => attr.Name.ToString().Equals(Definition.AttributeName))));
    }

    #endregion

    #region GenerateRuntimeInitializeOnLoadMethod

    private void GenerateRuntimeInitializeOnLoadMethodExecute(GeneratorExecutionContext context,
        IEnumerable<SyntaxTree> syntaxTrees)
    {
        var className = $"RuntimeInitializeOnLoadMethodCollector_Gen";
        StringBuilder strBuilder = new StringBuilder();
        List<string> methodNames = new List<string>();
        // 获取编译对象
        var compilation = context.Compilation;

        foreach (var tree in syntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(tree);
            // 获取语法树的根节点
            var root = tree.GetRoot();

            // 获取当前语法树中的所有命名空间节点
            var namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();

            // 判断语法树是否在指定检测的命名空间下
            if (namespaces.All(ns => !Definition.RuntimeInitializeTargetNameSpaces.Contains(ns.Name.ToString())))
            {
                continue;
            }

            var methods = GetMatchMethods(root);

            foreach (var methodNode in methods)
            {
                var methodSymbol = semanticModel.GetDeclaredSymbol(methodNode) as IMethodSymbol;
                var methodName = methodNode.Identifier.ToString();
                methodNames.Add(methodName);
                var fullName = GetMethodFullName(methodNode, methodName);
                GenerateRuntimeInitializeOnLoadClass(ref strBuilder, methodName, fullName, methodNode, methodSymbol);
            }
        }

        if (methodNames.Count > 0)
        {
            var str = GenerateRuntimeInitializeOnLoadFile(strBuilder, className);
            context.AddSource($"{className}.g.cs", str);
        }
    }

    private string GenerateRuntimeInitializeOnLoadFile(StringBuilder strBuilder, string className)
    {
        var strFile = new StringBuilder();
        strFile.AppendLine("using System;");
        strFile.AppendLine("using System.Collections.Generic;");
        strFile.AppendLine("using UnityEngine;");
        strFile.AppendLine();
        strFile.AppendLine($"namespace {Definition.RuntimeInitializeNameSpace}");
        strFile.AppendLine("{");
        {
            strFile.AppendLine($"\tpublic static class {className}");
            strFile.AppendLine("\t{");
            {
                strFile.AppendLine("\t\t/// <summary>");
                strFile.AppendLine("\t\t/// 存储所有被标记为RuntimeInitializeOnLoadMethod的方法信息");
                strFile.AppendLine("\t\t/// </summary>");
                strFile.AppendLine(
                    "\t\tpublic static readonly IReadOnlyList<RuntimeInitializeMethodInfo> Methods = new List<RuntimeInitializeMethodInfo>");
                strFile.AppendLine("\t\t{");
                {
                    strFile.Append(strBuilder);
                }
                strFile.AppendLine("\t\t};");
                strFile.AppendLine("");

                strFile.AppendLine(
                    "\t\tpublic static IReadOnlyList<RuntimeInitializeMethodInfo> GetMethodsByLoadType(RuntimeInitializeLoadType loadType)");
                strFile.AppendLine("\t\t{");
                {
                    strFile.AppendLine("\t\t\tvar result = new List<RuntimeInitializeMethodInfo>();");
                    strFile.AppendLine("\t\t\tfor(int i = 0; i < Methods.Count; i++)");
                    strFile.AppendLine("\t\t\t{");
                    {
                        strFile.AppendLine("\t\t\t\tif (loadType == Methods[i].InitializeLoadType)");
                        strFile.AppendLine("\t\t\t\t{");
                        {
                            strFile.AppendLine("\t\t\t\t\tresult.Add(Methods[i]);");
                        }
                        strFile.AppendLine("\t\t\t\t}");
                    }
                    strFile.AppendLine("\t\t\t}");
                    strFile.AppendLine("\t\t\treturn result;");
                }
                strFile.AppendLine("\t\t}");

                strFile.AppendLine("");

                strFile.AppendLine(
                    "\t\tpublic static IReadOnlyList<RuntimeInitializeMethodInfo> BeforeSceneLoadMethods => GetMethodsByLoadType(RuntimeInitializeLoadType.BeforeSceneLoad);");
                strFile.AppendLine(
                    "\t\tpublic static IReadOnlyList<RuntimeInitializeMethodInfo> AfterSceneLoadMethods => GetMethodsByLoadType(RuntimeInitializeLoadType.AfterSceneLoad);");
                strFile.AppendLine(
                    "\t\tpublic static IReadOnlyList<RuntimeInitializeMethodInfo> SubsystemRegistrationMethods => GetMethodsByLoadType(RuntimeInitializeLoadType.SubsystemRegistration);");
                strFile.AppendLine(
                    "\t\tpublic static IReadOnlyList<RuntimeInitializeMethodInfo> AfterAssembliesLoadedMethods => GetMethodsByLoadType(RuntimeInitializeLoadType.AfterAssembliesLoaded);");
                strFile.AppendLine(
                    "\t\tpublic static IReadOnlyList<RuntimeInitializeMethodInfo> BeforeSplashScreenMethods => GetMethodsByLoadType(RuntimeInitializeLoadType.BeforeSplashScreen);");
                strFile.AppendLine("");
                strFile.AppendLine("\t\tpublic static void ExecuteMethods(RuntimeInitializeLoadType loadType)");
                strFile.AppendLine("\t\t{");
                {
                    strFile.AppendLine("\t\t\tvar methods = GetMethodsByLoadType(loadType);");
                    strFile.AppendLine("\t\t\tif(methods == null || methods.Count == 0)");
                    strFile.AppendLine("\t\t\t{");
                    strFile.AppendLine("\t\t\t\treturn;");
                    strFile.AppendLine("\t\t\t}");
                    // strFile.AppendLine($"\t\t\t{Definition.DefaultDebugName}.Info($\"RuntimeInitializeLoadType: {loadType}\");");
                    strFile.AppendLine("\t\t\tfor(int i = 0; i < methods.Count; i++)");
                    strFile.AppendLine("\t\t\t{");
                    {
                        strFile.AppendLine("\t\t\t\ttry");
                        strFile.AppendLine("\t\t\t\t{");
                        {
                            strFile.AppendLine(
                                "\t\t\t\t\tvar assembly = GameStart.GetAssembly(methods[i].AssemblyName);");
                            strFile.AppendLine("\t\t\t\t\tif (assembly == null)");
                            strFile.AppendLine("\t\t\t\t\t{");
                            {
                                strFile.AppendLine(
                                    $"\t\t\t\t\t\t{Definition.DefaultDebugName}.Error($\"没有找到程序集: {{methods[i].AssemblyName}}\");");
                                strFile.AppendLine("\t\t\t\t\t\treturn;");
                            }
                            strFile.AppendLine("\t\t\t\t\t}");
                            strFile.AppendLine("\t\t\t\t\tvar type = assembly.GetType(methods[i].TypeName);");
                            strFile.AppendLine("\t\t\t\t\tif (type != null)");
                            strFile.AppendLine("\t\t\t\t\t{");
                            {
                                strFile.AppendLine(
                                    "\t\t\t\t\t\tvar method = type.GetMethod(methods[i].MethodName, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic);");
                                strFile.AppendLine("\t\t\t\t\t\tmethod?.Invoke(null, null);");
                            }
                            strFile.AppendLine("\t\t\t\t\t}");
                            strFile.AppendLine("\t\t\t\t\telse");
                            strFile.AppendLine("\t\t\t\t\t{");
                            strFile.AppendLine(
                                $"\t\t\t\t\t\t{Definition.DefaultDebugName}.Error($\"没找到类型{{methods[i].TypeName}}\");");
                            strFile.AppendLine("\t\t\t\t\t}");
                        }
                        strFile.AppendLine("\t\t\t\t}");
                        strFile.AppendLine("\t\t\t\tcatch (Exception ex)");
                        strFile.AppendLine("\t\t\t\t{");
                        {
                            strFile.AppendLine(
                                $"\t\t\t\t\t{Definition.DefaultDebugName}.Error($\"执行RuntimeInitializeOnLoadMethod方法失败: {{methods[i].FullName}}, 错误: {{ex.Message}}\");");
                        }
                        strFile.AppendLine("\t\t\t\t}");
                    }
                    strFile.AppendLine("\t\t\t}");
                }
                strFile.AppendLine("\t\t}");

                strFile.AppendLine("");
                strFile.AppendLine("\t\tpublic static void ExecuteAllMethods()");
                strFile.AppendLine("\t\t{");
                {
                    strFile.AppendLine("\t\t\tExecuteMethods(RuntimeInitializeLoadType.BeforeSplashScreen);");
                    strFile.AppendLine("\t\t\tExecuteMethods(RuntimeInitializeLoadType.AfterAssembliesLoaded);");
                    strFile.AppendLine("\t\t\tExecuteMethods(RuntimeInitializeLoadType.SubsystemRegistration);");
                    strFile.AppendLine("\t\t\tExecuteMethods(RuntimeInitializeLoadType.BeforeSceneLoad);");
                    strFile.AppendLine("\t\t\tExecuteMethods(RuntimeInitializeLoadType.AfterSceneLoad);");
                }
                strFile.AppendLine("\t\t}");
            }
            strFile.AppendLine("\t}");
            strFile.AppendLine("");
            strFile.AppendLine("\t/// <summary>");
            strFile.AppendLine("\t/// RuntimeInitializeOnLoadMethod方法信息");
            strFile.AppendLine("\t/// </summary>");
            strFile.AppendLine("\tpublic struct RuntimeInitializeMethodInfo");
            strFile.AppendLine("\t{");
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// 方法名");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic string MethodName;");
            strFile.AppendLine();
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// 程序集名");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic string AssemblyName;");
            strFile.AppendLine();
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// Type名");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic string TypeName;");
            strFile.AppendLine();
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// 类名");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic string ClassName;");
            strFile.AppendLine();
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// 完整方法名（包含类名和命名空间）");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic string FullName;");
            strFile.AppendLine();
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// 完整方法名（包含类名）");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic string FullMethodName;");
            strFile.AppendLine();
            strFile.AppendLine("\t\t/// <summary>");
            strFile.AppendLine("\t\t/// 初始化加载类型");
            strFile.AppendLine("\t\t/// </summary>");
            strFile.AppendLine("\t\tpublic RuntimeInitializeLoadType InitializeLoadType;");
            strFile.AppendLine("\t}");
        }
        strFile.AppendLine("}");

        return strFile.ToString();
    }

    private void GenerateRuntimeInitializeOnLoadClass(ref StringBuilder strBuilder, string methodName,
        string fullName, MethodDeclarationSyntax methodNode, IMethodSymbol methodSymbol)
    {
        var containingType = methodSymbol.ContainingType;
        var fullTypeName = containingType.ToDisplayString(); // 完整类型名（含命名空间）
        var assemblyName = containingType.ContainingAssembly?.Name ?? Definition.DefaultAssemblyName;
        var loadType = GetRuntimeInitializeLoadType(methodNode);
        var className = GetContainingClassName(methodNode);
        strBuilder.AppendLine("\t\t\tnew RuntimeInitializeMethodInfo");
        strBuilder.AppendLine("\t\t\t{");
        {
            strBuilder.AppendLine($"\t\t\t\tMethodName = \"{methodName}\",");
            strBuilder.AppendLine($"\t\t\t\tAssemblyName = \"{assemblyName}\",");
            strBuilder.AppendLine($"\t\t\t\tTypeName = \"{fullTypeName}\",");
            strBuilder.AppendLine($"\t\t\t\tClassName = \"{className}\",");
            strBuilder.AppendLine($"\t\t\t\tFullName  = \"{fullName}\",");
            strBuilder.AppendLine($"\t\t\t\tFullMethodName  = \"{className}.{methodName}\",");
            strBuilder.AppendLine($"\t\t\t\tInitializeLoadType   = RuntimeInitializeLoadType.{loadType},");
        }
        strBuilder.AppendLine("\t\t\t},");
    }

    private string GetContainingClassName(MethodDeclarationSyntax method)
    {
        // 获取方法所在的类名
        var classDeclaration = method.Ancestors()
            .OfType<ClassDeclarationSyntax>()
            .FirstOrDefault();

        return classDeclaration?.Identifier.ToString() ?? "UnknownClass";
    }

    private string GetRuntimeInitializeLoadType(MethodDeclarationSyntax method)
    {
        // 默认值为AfterSceneLoad
        var loadType = "AfterSceneLoad";

        // 查找RuntimeInitializeOnLoadMethod属性
        var attribute = method.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(attr =>
                attr.Name.ToString() == Definition.RuntimeInitializeAttributeName);

        if (attribute?.ArgumentList != null && attribute.ArgumentList.Arguments.Any())
        {
            // 获取第一个参数的值
            var argument = attribute.ArgumentList.Arguments[0];

            if (argument.Expression is MemberAccessExpressionSyntax memberAccess)
            {
                loadType = memberAccess.Name.ToString();
            }
            else if (argument.Expression is IdentifierNameSyntax identifierName)
            {
                loadType = identifierName.Identifier.ToString();
            }
            // 处理直接使用枚举值的情况
            else if (argument.Expression is MemberAccessExpressionSyntax)
            {
                var fullExpression = argument.Expression.ToString();

                if (fullExpression.Contains("RuntimeInitializeLoadType."))
                {
                    loadType = fullExpression.Split('.').Last();
                }
            }
        }

        return loadType;
    }

    /// <summary>
    /// 获取匹配的方法声明
    /// </summary>
    /// <param name="root"></param>
    /// <returns></returns>
    private IEnumerable<MethodDeclarationSyntax> GetMatchMethods(SyntaxNode root)
    {
        return root.DescendantNodes().OfType<MethodDeclarationSyntax>()
            .Where(i => i.AttributeLists.Count > 0
                        && i.AttributeLists.Any(attrList => attrList.Attributes
                            .Any(attr => attr.Name.ToString().Equals(Definition.RuntimeInitializeAttributeName))));
    }

    /// <summary>
    /// 获取方法的FullName带命名空间
    /// </summary>
    /// <param name="methodNode"></param>
    /// <param name="methodName"></param>
    /// <returns></returns>
    private string GetMethodFullName(MethodDeclarationSyntax methodNode, string methodName)
    {
        var className = GetContainingClassName(methodNode);
        var tempMethodName = $"{className}.{methodName}";
        var fullName = methodNode.SyntaxTree.GetRoot()
            .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
            .Select(nameSpace => nameSpace.Name.ToString())
            .Concat([tempMethodName])
            .Aggregate((a, b) => $"{a}.{b}");
        return fullName;
    }

    #endregion

    #region GenerateRuntimeInitializeOnLoadMethod

    private void GenerateRequireComponentExecute(GeneratorExecutionContext context,
        IEnumerable<SyntaxTree> syntaxTrees)
    {
        var className = $"RequireComponentCollector_Gen";
        var requiredTypes = new List<TypeInfo>();
        var requiredTypeNames = new List<string>();
        // 获取编译对象
        var compilation = context.Compilation;

        foreach (var tree in syntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(tree);
            // 获取语法树的根节点
            var root = tree.GetRoot();

            // 获取当前语法树中的所有命名空间节点
            var namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();

            // 判断语法树是否在指定检测的命名空间下
            if (namespaces.All(ns => !Definition.RequireComponentTargetNameSpaces.Contains(ns.Name.ToString())))
            {
                continue;
            }

            var classes = GetMatchClasses(root);

            foreach (var classDecl in classes)
            {
                var requireComponentAttributes = classDecl.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Where(attr =>
                        attr.Name.ToString() == Definition.RequireComponentAttributeName)
                    .ToList();

                foreach (var attribute in requireComponentAttributes)
                {
                    if (attribute.ArgumentList == null) continue;

                    foreach (var argument in attribute.ArgumentList.Arguments)
                    {
                        if (argument.Expression is TypeOfExpressionSyntax typeOfExpression)
                        {
                            // 使用语义模型获取完整的类型信息
                            var typeInfo = semanticModel.GetTypeInfo(typeOfExpression.Type);

                            if (typeInfo.Type != null)
                            {
                                // 检查是否为抽象类且尚未存在
                                if (!typeInfo.Type.IsAbstract && requiredTypes.All(t =>
                                        t.Type?.ToDisplayString() != typeInfo.Type.ToDisplayString()))
                                {
                                    // 获取完整的类型名称（包括命名空间）
                                    var fullTypeName = typeInfo.Type.ToDisplayString();
                                    requiredTypes.Add(typeInfo);
                                }
                            }
                            else
                            {
                                // 回退到语法分析
                                requiredTypeNames.Add(typeOfExpression.Type.ToString());
                            }
                        }
                    }
                }
            }
        }

        if (requiredTypes.Count > 0)
        {
            var str = GenerateRequireComponentFile(requiredTypes, requiredTypeNames);
            context.AddSource($"{className}.g.cs", str);
        }
    }

    private string GenerateRequireComponentFile(List<TypeInfo> requiredTypes, List<string> requiredTypeNames)
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        // sb.AppendLine("using UnityEngine;");
        // sb.AppendLine($"using {Definition.DefaultFrameworkNameSpace};");
        sb.AppendLine("using Cysharp.Threading.Tasks;");

        // for (int i = 0; i < requiredTypes.Count; i++)
        // {
        //     var typeInfo = requiredTypes[i];
        //     var namespaceName = typeInfo.Type?.ContainingNamespace?.ToDisplayString();
        //     if (!string.IsNullOrEmpty(namespaceName))
        //     {
        //         sb.AppendLine($"using {namespaceName};");
        //     }
        // }
        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.RequireComponentNameSpace}");
        sb.AppendLine("{");
        {
            sb.AppendLine("\tpublic static class RequireComponentCollector_Gen");
            sb.AppendLine("\t{");
            {
                sb.AppendLine(
                    "\t\tpublic static readonly IReadOnlyList<Type> RequireComponentTypes = new List<Type>");
                sb.AppendLine("\t\t{");
                {
                    for (int i = 0; i < requiredTypes.Count; i++)
                    {
                        var typeInfo = requiredTypes[i];

                        if (typeInfo.Type != null)
                        {
                            sb.AppendLine($"\t\t\ttypeof({typeInfo.Type.ToDisplayString()}),");
                        }
                    }

                    for (int i = 0; i < requiredTypeNames.Count; i++)
                    {
                        var typeName = requiredTypeNames[i];

                        if (!string.IsNullOrEmpty(typeName))
                        {
                            sb.AppendLine($"\t\t\ttypeof({typeName}),");
                        }
                    }
                }
                sb.AppendLine("\t\t};");
                sb.AppendLine("");
                sb.AppendLine("\t\tpublic static void StartAddComponents()");
                sb.AppendLine("\t\t{");
                {
                    sb.AppendLine("\t\t\tAddComponents().Forget();");
                }
                sb.AppendLine("\t\t}");
                sb.AppendLine("");
                sb.AppendLine("\t\tpublic static async UniTaskVoid AddComponents()");
                sb.AppendLine("\t\t{");
                {
                    sb.AppendLine("\t\t\tvar go = new UnityEngine.GameObject(\"[RequireComponentCollector]\");");
                    sb.AppendLine("\t\t\tfor(int i = 0; i < RequireComponentTypes.Count; i++)");
                    sb.AppendLine("\t\t\t{");
                    {
                        sb.AppendLine("\t\t\t\tvar tempType = RequireComponentTypes[i];");
                        // sb.AppendLine("\t\t\t\tif(tempType.IsAbstract || tempType.IsInterface) continue;");
                        sb.AppendLine("\t\t\t\tif (!go.TryGetComponent(tempType, out _))");
                        sb.AppendLine("\t\t\t\t{");
                        {
                            sb.AppendLine("\t\t\t\t\tvar comp = go.AddComponent(tempType);");
                            sb.AppendLine("\t\t\t\t\tif (comp != null)");
                            sb.AppendLine("\t\t\t\t\t{");
                            {
                                sb.AppendLine("\t\t\t\t\t\tUnityEngine.GameObject.Destroy(comp);");
                                sb.AppendLine("\t\t\t\t\t\tawait UniTask.Yield();");
                            }
                            sb.AppendLine("\t\t\t\t\t}");
                        }
                        sb.AppendLine("\t\t\t\t}");
                        // sb.AppendLine($"\t\t\t\t{Definition.DefaultDebugName}.Info(\"RequireComponentCollector: \" + go.TryGetComponent(tempType, out _));");
                    }
                    sb.AppendLine("\t\t\t}");
                    sb.AppendLine("\t\t\tUnityEngine.GameObject.Destroy(go);");
                    sb.AppendLine("\t\t\tawait UniTask.Yield();");
                    // sb.AppendLine($"\t\t\t{Definition.DefaultDebugName}.Info($\"RequireComponentCollector DestroyImmediate: {UnityEngine.GameObject.Find(\"[RequireComponentCollector]\")}\");");
                }
                sb.AppendLine("\t\t}");
            }
            sb.AppendLine("\t}");
        }
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// 获取匹配的方法声明
    /// </summary>
    /// <param name="root"></param>
    /// <returns></returns>
    private IEnumerable<ClassDeclarationSyntax> GetMatchClasses(SyntaxNode root)
    {
        return root.DescendantNodes().OfType<ClassDeclarationSyntax>()
            .Where(i => i.AttributeLists.Count > 0
                        && i.AttributeLists.Any(attrList => attrList.Attributes
                            .Any(attr => attr.Name.ToString().Equals(Definition.RequireComponentAttributeName))));
    }

    #endregion

    #region GenerateGameEvent

    private void GenerateTextDefineEnumExecute(GeneratorExecutionContext context, IEnumerable<SyntaxTree> syntaxTrees)
    {
        List<string> enumMembers = new List<string>();

        foreach (var tree in syntaxTrees)
        {
            // 获取语法树的根节点
            var root = tree.GetRoot();

            // 获取当前语法树中的所有命名空间节点
            var namespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();

            // 判断语法树是否在指定检测的命名空间下
            if (namespaces.All(ns => !Definition.TextDefineTargetNameSpaces.Contains(ns.Name.ToString())))
            {
                continue;
            }

            var enums = GetMatchEnums(root);

            foreach (var item in enums)
            {
                var tempEnumMembers = item.DescendantNodes()
                    .OfType<EnumMemberDeclarationSyntax>()
                    .Select(member => member.Identifier.ToString())
                    .ToList();
                enumMembers.AddRange(tempEnumMembers);
            }
        }

        if (enumMembers.Count > 0)
        {
            var enumClassName = $"{Definition.TextDefineEnumName}Converter";
            var sourceCode = GenerateConverterClass(enumClassName, enumMembers);
            // 添加到编译上下文中
            context.AddSource($"{enumClassName}.g.cs", sourceCode);
        }
    }

    /// <summary>
    /// 生成TextDefineConverter
    /// </summary>
    /// <param name="enumMembers"></param>
    /// <returns></returns>
    private string GenerateConverterClass(string enumClassName, List<string> enumMembers)
    {
        var sb = new StringBuilder();
        sb.AppendLine("//----------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// \tThis code was generated by the source generator.");
        sb.AppendLine("// \tChanges to this file may cause incorrect behavior.");
        sb.AppendLine("// \twill be lost if the code is regenerated.");
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("//----------------------------------------------------------");

        sb.AppendLine();
        sb.AppendLine($"namespace {Definition.TextDefineNameSpace}");
        {
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic class {enumClassName}");
            {
                sb.AppendLine("\t{");
                sb.AppendLine($"\t\tpublic static string Convert({Definition.TextDefineEnumName} textDefine)");
                {
                    sb.AppendLine("\t\t\t=> textDefine switch");
                    sb.AppendLine("\t\t\t{");
                    {
                        foreach (var enumName in enumMembers)
                        {
                            sb.AppendLine($"\t\t\t\t{Definition.TextDefineEnumName}.{enumName} => nameof({Definition.TextDefineEnumName}.{enumName}),");
                        }
                        sb.AppendLine($"\t\t\t\t_ => textDefine.ToString(),");
                    }
                    sb.AppendLine("\t\t\t};");
                }
                sb.AppendLine("\t}");
            }
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// 获取匹配的接口声明语法
    /// </summary>
    /// <param name="root"></param>
    /// <returns></returns>
    private IEnumerable<EnumDeclarationSyntax> GetMatchEnums(SyntaxNode root)
    {
        return root.DescendantNodes().OfType<EnumDeclarationSyntax>()
            .Where(e => e.Identifier.ValueText == Definition.TextDefineEnumName);
    }

    #endregion
}